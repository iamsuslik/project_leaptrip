from contextlib import asynccontextmanager
from django.http import FileResponse
from fastapi import Depends, FastAPI, HTTPException, Request, Response, status
from authx import AuthX, AuthXConfig, TokenPayload
from pydantic import BaseModel, Field, validator
from databases import Database
from sqlalchemy import create_engine, MetaData, Table, Column, String, Boolean, Integer, UniqueConstraint
from passlib.context import CryptContext
import re
import os
from typing import List, Optional
from datetime import datetime
from fastapi.templating import Jinja2Templates 
import httpx
from cachetools import TTLCache
from fastapi.middleware.cors import CORSMiddleware
from dateutil import parser, tz
import logging
from dotenv import load_dotenv

load_dotenv()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")



DATABASE_URL = os.getenv("DATABASE_URL")
database = Database(DATABASE_URL)
metadata = MetaData()


users = Table(
    "usersversion1",
    metadata,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("username", String, unique=True),
    Column("email", String, unique=True),
    Column("password", String),
    Column("is_active", Boolean, default=True),
    UniqueConstraint('email', name='unique_email')
)

@asynccontextmanager
async def lifespan(app: FastAPI):
    try:
        await database.connect()
        print("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î —É—Å–ø–µ—à–Ω–æ!")

        engine = create_engine(DATABASE_URL.replace("+asyncpg", ""))
        metadata.create_all(engine)
        print("‚úÖ –¢–∞–±–ª–∏—Ü–∞ 'users' —Å–æ–∑–¥–∞–Ω–∞ (–∏–ª–∏ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)")

        yield
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫ –ë–î: {e}")
        raise
    finally:
        await database.disconnect()

app = FastAPI(lifespan=lifespan)


app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], 
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


templates = Jinja2Templates(directory="templates")
cache = TTLCache(maxsize=100, ttl=3600)
    


config = AuthXConfig()
config.JWT_SECRET_KEY = "SECRET_KEY"
config.JWT_ACCESS_COOKIE_NAME = "my_access_token"
config.JWT_TOKEN_LOCATION = ["cookies"]
config.JWT_IDENTITY_CLAIM = "sub"

security = AuthX(config=config)



class UserLoginSchema(BaseModel):
    username_or_email: str
    password: str

class UserCreateSchema(BaseModel):
    username: str
    email: str
    password: str

def is_valid_email(email: str) -> bool:
    pattern = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$'
    return re.match(pattern, email) is not None

@app.get("/")
async def home():
    return {"message": "Welcome to the API!"}



# @app.post("/register")
# async def register(user: UserCreateSchema):
#     print(f"üîπ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {user.username}")  # –õ–æ–≥ 1
    
#     # Check if username already exists
#     query = users.select().where(users.c.username == user.username)
#     existing_user = await database.fetch_one(query)
    
#     if existing_user:
#         print("üî¥ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!")  # –õ–æ–≥ 2
#         raise HTTPException(status_code=400, detail="Username already registered")
    
#     # Check if email already exists
#     query = users.select().where(users.c.email == user.email)
#     existing_email = await database.fetch_one(query)
    
#     if existing_email:
#         print("üî¥ Email —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω!")  # –õ–æ–≥ 2
#         raise HTTPException(status_code=400, detail="Email already registered")
    
#     hashed_password = pwd_context.hash(user.password)
#     print(f"üîπ –•–µ—à –ø–∞—Ä–æ–ª—è: {hashed_password}")  # –õ–æ–≥ 3
    
#     query = users.insert().values(
#         username=user.username,
#         email=user.email,
#         password=hashed_password,
#         is_active=True
#     )
#     await database.execute(query)
#     print("üü¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω –≤ –ë–î!")  # –õ–æ–≥ 4
    
#     return {"message": "User created successfully"}

@app.post("/register")
async def register(
    user: UserCreateSchema, 
    response: Response,
    request: Request  # –î–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
):
    print(f"\nüîπ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {user.username}")
    print(f"üî∏ IP: {request.client.host if request.client else 'unknown'}")

    try:
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ username
        query = users.select().where(users.c.username == user.username)
        existing_user = await database.fetch_one(query)
        
        if existing_user:
            print("üî¥ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already registered"
            )
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ email
        query = users.select().where(users.c.email == user.email)
        existing_email = await database.fetch_one(query)
        
        if existing_email:
            print("üî¥ Email —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω!")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )
        
        # –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è
        hashed_password = pwd_context.hash(user.password)
        print(f"üîπ –•–µ—à –ø–∞—Ä–æ–ª—è: {hashed_password}")
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        query = users.insert().values(
            username=user.username,
            email=user.email,
            password=hashed_password,
            is_active=True
        )
        user_id = await database.execute(query)
        print("üü¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω –≤ –ë–î!")

        # –°–æ–∑–¥–∞–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞ –¥–ª—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        token = security.create_access_token(uid=user.username)
        print(f"üîπ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω —Ç–æ–∫–µ–Ω –¥–ª—è {user.username}")

        # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–æ–∫–µ–Ω–∞ –≤ –∫—É–∫–∏
        response.set_cookie(
            key=config.JWT_ACCESS_COOKIE_NAME,
            value=token,
            httponly=True,
            secure=False,
            samesite="lax",
            max_age=config.JWT_ACCESS_TOKEN_EXPIRES.total_seconds(),
            path="/",
        )

        print("üü¢ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —É—Å–ø–µ—à–Ω—ã")
        print(f"üîπ Token: {token[:15]}...")

        return {
            "message": "User created and authenticated successfully",
            "access_token": token,
            "token_type": "bearer",
            "user_id": user_id,
            "username": user.username
        }

    except Exception as e:
        print(f"üî¥ –û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during registration"
        )

# @app.post("/login")
# async def login(creds: UserLoginSchema, response: Response):
#     # Determine if login is by email or username
#     if is_valid_email(creds.username_or_email):
#         query = users.select().where(users.c.email == creds.username_or_email)
#     else:
#         query = users.select().where(users.c.username == creds.username_or_email)
    
#     user = await database.fetch_one(query)
    
#     if not user or not user.is_active:
#         raise HTTPException(status_code=401, detail="User not found or inactive")
    
#     if not pwd_context.verify(creds.password, user.password):
#         raise HTTPException(status_code=401, detail="Incorrect password")
    
#     token = security.create_access_token(uid=user.username)
#     response.set_cookie(config.JWT_ACCESS_COOKIE_NAME, token)
#     return {"access_token": token}


@app.post("/login")
async def login(
    creds: UserLoginSchema,
    response: Response,
    request: Request  # –î–æ–±–∞–≤–∏–º –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
):
    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ö–æ–¥—è—â–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    print(f"\nüîπ Login attempt for: {creds.username_or_email}")
    print(f"üî∏ IP: {request.client.host if request.client else 'unknown'}")

    try:
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ (email/username)
        if is_valid_email(creds.username_or_email):
            query = users.select().where(users.c.email == creds.username_or_email)
            auth_type = "email"
        else:
            query = users.select().where(users.c.username == creds.username_or_email)
            auth_type = "username"

        print(f"üîπ Auth type: {auth_type}")

        user = await database.fetch_one(query)

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        if not user:
            print("üî¥ User not found")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found"
            )

        if not user.is_active:
            print("üî¥ User inactive")
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User inactive"
            )

        if not pwd_context.verify(creds.password, user.password):
            print("üî¥ Invalid password")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect password"
            )

        token = security.create_access_token(uid=user.username)
        print(f"üîπ Generated token for {user.username}")

        response.set_cookie(
            key=config.JWT_ACCESS_COOKIE_NAME,
            value=token,
            httponly=True,
            secure=False,
            samesite="lax",
            max_age=config.JWT_ACCESS_TOKEN_EXPIRES.total_seconds(),
            path="/",
        )

        print("üü¢ Login successful")
        print(f"üîπ Token: {token[:15]}...")

        return {
            "access_token": token,
            "token_type": "bearer",
            "user_id": user.id,
            "username": user.username
        }

    except Exception as e:
        print(f"üî¥ Login error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during login"
        )




# class UserResponse(BaseModel):
#     id: int
#     username: str
#     email: str
#     is_active: bool

# @app.get("/user", response_model=UserResponse)
# async def get_current_user(
#     current_user: str = Depends(security.access_token_required)
# ):
#     username = current_user
    
#     query = users.select().where(users.c.username == username)
#     user = await database.fetch_one(query)
    
#     if not user:
#         raise HTTPException(
#             status_code=status.HTTP_404_NOT_FOUND,
#             detail="User not found"
#         )
    
#     if not user.is_active:
#         raise HTTPException(
#             status_code=status.HTTP_403_FORBIDDEN,
#             detail="User inactive"
#         )
    
#     return {
#         "id": user.id,
#         "username": user.username,
#         "email": user.email,
#         "is_active": user.is_active
#     }



class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    is_active: bool

@app.get("/user")
async def get_current_user(
    token_payload: TokenPayload = Depends(security.access_token_required)
):
    logger.debug(f"Received token payload: {token_payload}")
    try:
        username = token_payload.sub
        if not username:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token: missing username"
            )

        query = users.select().where(users.c.username == username)
        user = await database.fetch_one(query)

        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )

        if not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User inactive"
            )

        return {
            "id": user.id,
            "username": user.username,
            "email": user.email,
            "is_active": user.is_active
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}"
        )

####################################################################################################
#  –ø–∞—Ä—Å–∏–Ω–≥ –∞–≤–∏–∞–±–∏–ª–µ—Ç–æ–≤ 

logging.basicConfig(level=logging.DEBUG) 
logger = logging.getLogger(__name__)


API_URL = "https://api.travelpayouts.com/aviasales/v3/prices_for_dates"
API_TOKEN = os.getenv("API_TOKEN")
TIMEOUT = 30

AIRLINE_NAMES = {
    # –†–æ—Å—Å–∏–π—Å–∫–∏–µ –∞–≤–∏–∞–∫–æ–º–ø–∞–Ω–∏–∏
    "SU": "–ê—ç—Ä–æ—Ñ–ª–æ—Ç",
    "S7": "S7 Airlines",
    "U6": "–£—Ä–∞–ª—å—Å–∫–∏–µ –∞–≤–∏–∞–ª–∏–Ω–∏–∏",
    "DP": "–ü–æ–±–µ–¥–∞",
    "WZ": "Red Wings",
    "2S": "Southwind",
    "N4": "Nordwind Airlines",
    "EO": "Pegas Fly",
    "D2": "Severstal Air",
    "Y7": "NordStar Airlines",
    "B2": "–ë–µ–ª–∞–≤–∏–∞",
    "5N": "Smartavia",
    "ZF": "–ê–∑–∏–º—É—Ç",
    "I8": "–ò–∂–∞–≤–∏–∞",
    
    # –ú–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã–µ –∞–≤–∏–∞–∫–æ–º–ø–∞–Ω–∏–∏
    "TK": "Turkish Airlines",
    "LH": "Lufthansa",
    "AF": "Air France",
    "BA": "British Airways",
    "KL": "KLM",
    "AZ": "Alitalia",
    "EY": "Etihad Airways",
    "EK": "Emirates",
    "QR": "Qatar Airways",
    "CX": "Cathay Pacific",
    "SQ": "Singapore Airlines",
    "JL": "Japan Airlines",
    "KE": "Korean Air",
    "TG": "Thai Airways",
    "QF": "Qantas",
    
    # –ë—é–¥–∂–µ—Ç–Ω—ã–µ –ø–µ—Ä–µ–≤–æ–∑—á–∏–∫–∏
    "FR": "Ryanair",
    "U2": "easyJet",
    "TR": "Scoot",
    "AK": "AirAsia",
    "FV": "Rossiya Airlines",
    "DV": "SCAT Airlines",
    "5F": "Fly Arna",
    
    # –ü–æ—Å—Ç—Å–æ–≤–µ—Ç—Å–∫–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ
    "HY": "Uzbekistan Airways",
    "KC": "Air Astana",
    "A9": "Georgian Airways",
    "5L": "FlyArystan",
    "JU": "Air Serbia",
    "BT": "Air Baltic",
    
    # –ß–∞—Ä—Ç–µ—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã
    "XU": "South East Asian Airlines",
    "VQ": "VQ Aviation",
    "3O": "Air Arabia Maroc",
    
    # –ì—Ä—É–∑–æ–≤—ã–µ –∞–≤–∏–∞–ª–∏–Ω–∏–∏
    "RU": "AirBridgeCargo",
    "K4": "Kalitta Air",
    "5Y": "Atlas Air"
}



CITY_NAMES_TO_IATA = {
    # –†–æ—Å—Å–∏–π—Å–∫–∏–µ –≥–æ—Ä–æ–¥–∞
    "–º–æ—Å–∫–≤–∞": "MOW", "—Å–∞–Ω–∫—Ç-–ø–µ—Ç–µ—Ä–±—É—Ä–≥": "LED", "–∫–∞–∑–∞–Ω—å": "KZN",
    "–µ–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥": "SVX", "–Ω–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫": "OVB", "—Å–æ—á–∏": "AER",
    "–∫—Ä–∞—Å–Ω–æ–¥–∞—Ä": "KRR", "—É—Ñ–∞": "UFA", "—Å–∞–º–∞—Ä–∞": "KUF",
    "—Ä–æ—Å—Ç–æ–≤-–Ω–∞-–¥–æ–Ω—É": "ROV", "–≤–æ–ª–≥–æ–≥—Ä–∞–¥": "VOG", "–ø–µ—Ä–º—å": "PEE",
    "–≤–æ—Ä–æ–Ω–µ–∂": "VOZ", "–æ–º—Å–∫": "OMS", "–∫—Ä–∞—Å–Ω–æ—è—Ä—Å–∫": "KJA",
    "–∏—Ä–∫—É—Ç—Å–∫": "IKT", "–≤–ª–∞–¥–∏–≤–æ—Å—Ç–æ–∫": "VVO", "—Ö–∞–±–∞—Ä–æ–≤—Å–∫": "KHV",
    "–∫–∞–ª–∏–Ω–∏–Ω–≥—Ä–∞–¥": "KGD", "–º—É—Ä–º–∞–Ω—Å–∫": "MMK", "–∞—Å—Ç—Ä–∞—Ö–∞–Ω—å": "ASF",
    "–±–µ–ª–≥–æ—Ä–æ–¥": "EGO", "—Ç—é–º–µ–Ω—å": "TJM", "–æ—Ä–µ–Ω–±—É—Ä–≥": "REN", "–ø–µ–Ω–∑–∞": "PEZ",
    
    # –ú–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–°–ù–ì/–ê–∑–∏—è)
    "—Å—Ç–∞–º–±—É–ª": "IST", "–∞–Ω—Ç–∞–ª—å—è": "AYT", "–¥—É–±–∞–π": "DXB",
    "—Ç–µ–≥–µ—Ä–∞–Ω": "IKA", "–µ—Ä–µ–≤–∞–Ω": "EVN", "–±–∞–∫—É": "GYD",
    "—Ç–∞—à–∫–µ–Ω—Ç": "TAS", "–∞–ª–º–∞—Ç—ã": "ALA", "–±–∏—à–∫–µ–∫": "FRU",
    "–¥—É—à–∞–Ω–±–µ": "DYU", "–∞—Å—Ç–∞–Ω–∞": "NQZ", "–∫–∏–µ–≤": "IEV",
    "–º–∏–Ω—Å–∫": "MSQ", "—Ç–∞—à–∫–µ–Ω—Ç": "TAS", "–∞—à—Ö–∞–±–∞–¥": "ASB",
    
    # –ï–≤—Ä–æ–ø–∞
    "–ª–æ–Ω–¥–æ–Ω": "LON", "–ø–∞—Ä–∏–∂": "PAR", "–±–µ—Ä–ª–∏–Ω": "BER",
    "—Ä–∏–º": "ROM", "–º–∞–¥—Ä–∏–¥": "MAD", "–±–∞—Ä—Å–µ–ª–æ–Ω–∞": "BCN",
    "–º–∏–ª–∞–Ω": "MIL", "–≤–µ–Ω–∞": "VIE", "–ø—Ä–∞–≥–∞": "PRG",
    "–≤–∞—Ä—à–∞–≤–∞": "WAW", "–±—É–¥–∞–ø–µ—à—Ç": "BUD", "–∞–º—Å—Ç–µ—Ä–¥–∞–º": "AMS",
    "–±—Ä—é—Å—Å–µ–ª—å": "BRU", "–∞—Ñ–∏–Ω—ã": "ATH", "—Ö–µ–ª—å—Å–∏–Ω–∫–∏": "HEL",
    
    # –ê–∑–∏—è
    "—Ç–æ–∫–∏–æ": "TYO", "–ø–µ–∫–∏–Ω": "BJS", "—à–∞–Ω—Ö–∞–π": "SHA",
    "—Å–µ—É–ª": "SEL", "–±–∞–Ω–≥–∫–æ–∫": "BKK", "—Å–∏–Ω–≥–∞–ø—É—Ä": "SIN",
    "–∫—É–∞–ª–∞-–ª—É–º–ø—É—Ä": "KUL", "–¥–∂–∞–∫–∞—Ä—Ç–∞": "CGK", "–º–∞–Ω–∏–ª–∞": "MNL",
    "–¥–µ–ª–∏": "DEL", "–º—É–º–±–∞–∏": "BOM", "–¥—É–±–ª–∏–Ω": "DUB",
    
    # –ê–º–µ—Ä–∏–∫–∞
    "–Ω—å—é-–π–æ—Ä–∫": "NYC", "–ª–æ—Å-–∞–Ω–¥–∂–µ–ª–µ—Å": "LAX", "–º–∞–π–∞–º–∏": "MIA",
    "—á–∏–∫–∞–≥–æ": "CHI", "—Ç–æ—Ä–æ–Ω—Ç–æ": "YYZ", "–º–µ—Ö–∏–∫–æ": "MEX",
    "—Å–∞–Ω-–ø–∞—É–ª—É": "GRU", "—Ä–∏–æ-–¥–µ-–∂–∞–Ω–µ–π—Ä–æ": "GIG", "–±—É—ç–Ω–æ—Å-–∞–π—Ä–µ—Å": "EZE",
    
    # –ë–ª–∏–∂–Ω–∏–π –í–æ—Å—Ç–æ–∫
    "—Ç–µ–ª—è–≤–∏–≤": "TLV", "—ç–ª—å-–∫—É–≤–µ–π—Ç": "KWI", "–¥–æ—Ö–∞": "DOH",
    "—ç—Ä-—Ä–∏—è–¥": "RUH", "–¥–∂–∏–¥–¥–∞": "JED", "–º—É—Å–∫–∞—Ç": "MCT",
    
    # –ê—Ñ—Ä–∏–∫–∞
    "–∫–∞–∏—Ä": "CAI", "–π–æ—Ö–∞–Ω–Ω–µ—Å–±—É—Ä–≥": "JNB", "–Ω–∞–π—Ä–æ–±–∏": "NBO",
    "–∫–∞—Å–∞–±–ª–∞–Ω–∫–∞": "CMN", "–¥–∞–≥–µ—Ä": "DKR", "–∞–∫–∫—Ä–∞": "ACC"
}


class FlightRequest(BaseModel):
    origin: str = Field(..., alias="fromCity")
    destination: str = Field(..., alias="toCity") 
    depart_date: str =Field(..., alias="departureDate")
    return_date: Optional[str] = Field(None, alias="returnDate")
    one_way: bool = Field(False, alias="oneWay")
    direct: bool = Field(False, alias="direct")
    limit: int = Field(10, alias="limit")

    @validator("depart_date", "return_date")
    def validate_date_format(cls, v):
        if v:
            try:
                parser.parse(v).date()  # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–∞—Ç–∞ –ø–∞—Ä—Å–∏—Ç—Å—è
            except ValueError:
                raise ValueError("–î–∞—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î")
        return v

class FlightResponse(BaseModel):
    airline: str
    flight_number: str
    departure_at: str
    return_at: Optional[str]
    price: int
    transfers: str
    duration: str
    booking_url: str

class FlightSearchResponse(BaseModel):
    flights: List[FlightResponse]
    
def city_name_to_iata(city_name: str) -> str:
    city_name_lower = city_name.strip().lower()
    if city_name_lower in CITY_NAMES_TO_IATA:
        return CITY_NAMES_TO_IATA[city_name_lower]
    
    if len(city_name) == 3 and city_name.isupper():
        return city_name
    
    raise HTTPException(status_code=400, detail=f"–ì–æ—Ä–æ–¥ '{city_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞ –∏–ª–∏ –∫–æ–¥ IATA")

async def fetch_flights(params: dict) -> List[dict]:
    try:
        headers = {
            "X-Access-Token": API_TOKEN,
            "User-Agent": "Mozilla/5.0",  
        }
        
        params.update({
            "currency": "rub",
            "sorting": "price",
            "flexible_dates": "1", 
        })
        
        async with httpx.AsyncClient(timeout=TIMEOUT) as client:
            r = await client.get(API_URL, params=params, headers=headers)
            r.raise_for_status()
            data = r.json()
            
            logger.debug(f"Raw API data: {data}") 
            
            if not data.get("success", True):
                logger.error(f"API Error: {data.get('error')}")
                return []
                
            return data.get("data", [])
            
    except httpx.RequestError as e:
        logger.error(f"Request failed: {e}")
        return []

def format_time(dt_str: str, timezone="Europe/Moscow") -> str:
    try:
        dt = parser.parse(dt_str)
        if not dt.tzinfo:
            dt = dt.replace(tzinfo=tz.UTC)
        local_dt = dt.astimezone(tz.gettz(timezone))
        return local_dt.strftime("%Y-%m-%d %H:%M")
    except Exception:
        logger.warning(f"Error formatting time: {dt_str}")
        return dt_str

def parse_duration(duration_minutes: int) -> str:
    hours = duration_minutes // 60
    minutes = duration_minutes % 60
    return f"{hours}—á {minutes}–º" if hours > 0 else f"{minutes}–º"

@app.post("/flights/search", response_model=List[FlightResponse])
async def search_flights(request: FlightRequest, raw_request: Request):
    request_body = await raw_request.body()
    logger.info(f"–ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å: {request_body.decode()}")
    try:
        origin_iata = city_name_to_iata(request.origin)
        destination_iata = city_name_to_iata(request.destination)
        
        depart_date = parser.parse(request.depart_date).date()
        if depart_date < datetime.now().date():
            raise HTTPException(400, "–î–∞—Ç–∞ –≤—ã–ª–µ—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤ –±—É–¥—É—â–µ–º")

        params = {
            "origin": origin_iata,
            "destination": destination_iata,
            "departure_at": request.depart_date,
            "one_way": str(request.one_way).lower(),
            "direct": str(request.direct).lower(),
            "limit": request.limit,
        }

        if request.return_date and not request.one_way:
            return_date = parser.parse(request.return_date).date()
            if return_date <= depart_date:
                raise HTTPException(400, "–î–∞—Ç–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–∑–∂–µ –≤—ã–ª–µ—Ç–∞")
            params["return_at"] = request.return_date

        flights = await fetch_flights(params)
        if not flights:
            raise HTTPException(404, "–†–µ–π—Å—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")

        results = []
        for flight in flights[:request.limit]:
            try:
                price = int(flight.get("price", 0))
                if price <= 0:
                    continue

                airline = AIRLINE_NAMES.get(flight.get("airline", ""), flight.get("airline", "Unknown"))
                
                booking_url = (
                    f"https://www.aviasales.ru/redirect?flight_token={flight['flight_token']}"
                    if flight.get("flight_token")
                    else f"https://www.aviasales.ru/search?origin={origin_iata}&destination={destination_iata}"
                )

                departure_at = format_time(flight["departure_at"])
                return_at = format_time(flight["return_at"]) if flight.get("return_at") else None
                duration = parse_duration(flight.get('duration', 0)) 

                results.append(FlightResponse(
                    airline=airline,
                    flight_number=flight.get("flight_number", ""),
                    departure_at=departure_at,
                    return_at=return_at,
                    price=price,
                    transfers="–ü—Ä—è–º–æ–π" if flight.get("transfers", 0) == 0 else f"{flight['transfers']} –ø–µ—Ä–µ—Å–∞–¥–∫–∏",
                    duration=duration,
                    booking_url=booking_url,
                ))
            except Exception as e:
                logger.warning(f"Skipping flight due to error: {e}")

        return results

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Server error: {e}", exc_info=True)
        raise HTTPException(500, "Internal server error")



 
####################################################################################################
# –ø–∞—Ä—Å–∏–Ω–≥ –æ—Ç–µ–ª–µ–π

HOTELS_API_URL = "https://engine.hotellook.com/api/v2/cache.json"
API_TOKEN = os.getenv("API_TOKEN")
TIMEOUT = 30

class HotelRequest(BaseModel):
    city: str  # –ù–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞
    check_in: str  # —Ñ–æ—Ä–º–∞—Ç: –ì–ì–ì–ì-–ú–ú-–î–î
    check_out: str  # —Ñ–æ—Ä–º–∞—Ç: –ì–ì–ì–ì-–ú–ú-–î–î
    adults: int = 2
    stars: Optional[List[int]] = None  # –Ω–∞–ø—Ä–∏–º–µ—Ä [3,4,5]
    price_min: Optional[int] = None  # –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ü–µ–Ω–∞ –∑–∞ –≤–µ—Å—å –ø–µ—Ä–∏–æ–¥
    price_max: Optional[int] = None  # –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Ü–µ–Ω–∞ –∑–∞ –≤–µ—Å—å –ø–µ—Ä–∏–æ–¥
    limit: int = 10

class HotelResponse(BaseModel):
    name: str
    stars: int
    price: int  # –æ–±—â–∞—è —Ü–µ–Ω–∞
    price_per_night: int
    location: dict  # {lat, lon}
    booking_url: str

async def fetch_hotels(params: dict) -> List[dict]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–µ–ª–µ–π –∏–∑ API"""
    try:
        params.update({
            "token": API_TOKEN,
            "currency": "rub",
            "lang": "ru"
        })
        
        async with httpx.AsyncClient(timeout=TIMEOUT) as client:
            response = await client.get(HOTELS_API_URL, params=params)
            logger.debug(f"–û—Ç–≤–µ—Ç API: {response.status_code}, {response.text[:200]}...")
            
            if response.status_code != 200:
                logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ API: {response.status_code}")
                return []
            
            data = response.json()
            
            if isinstance(data, dict) and 'hotels' in data:
                return data['hotels']
            elif isinstance(data, list):
                return data
            else:
                logger.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞ API: {type(data)}")
                return []
                
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ—Ç–µ–ª–µ–π: {str(e)}", exc_info=True)
        return []

def process_hotel(hotel: dict, nights: int) -> Optional[dict]:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –æ—Ç–µ–ª—è"""
    try:
        price = hotel.get('priceAvg') or hotel.get('priceFrom')
        if price is None:
            logger.warning(f"–ü—Ä–æ–ø—É—Å–∫–∞–µ–º –æ—Ç–µ–ª—å {hotel.get('hotelName')} - –Ω–µ—Ç —Ü–µ–Ω—ã")
            return None
            
        price = int(price)
        
        location_data = hotel.get('location', {}).get('geo', {})
        location = {
            'lat': location_data.get('lat', 0),
            'lon': location_data.get('lon', 0)
        }
        
        booking_url = f"https://search.hotellook.com/?hotelId={hotel.get('hotelId')}"
        
        return {
            'name': hotel.get('hotelName', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –æ—Ç–µ–ª—å'),
            'stars': hotel.get('stars', 0),
            'price': price,
            'price_per_night': round(price / nights) if nights > 0 else price,
            'location': location,
            'booking_url': booking_url
        }
    except Exception as e:
        logger.warning(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç–µ–ª—è: {str(e)}")
        return None

@app.post("/hotels/search", response_model=List[HotelResponse])
async def search_hotels(request: HotelRequest):
    """–ü–æ–∏—Å–∫ –æ—Ç–µ–ª–µ–π"""
    try:
        try:
            check_in = parser.parse(request.check_in).date()
            check_out = parser.parse(request.check_out).date()
            
            if check_in < datetime.now().date():
                raise HTTPException(400, "–î–∞—Ç–∞ –∑–∞–µ–∑–¥–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤ –±—É–¥—É—â–µ–º")
            if check_out <= check_in:
                raise HTTPException(400, "–î–∞—Ç–∞ –≤—ã–µ–∑–¥–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ—Å–ª–µ –¥–∞—Ç—ã –∑–∞–µ–∑–¥–∞")
                
            nights = (check_out - check_in).days
        except Exception as e:
            raise HTTPException(400, f"–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã: {str(e)}")

        params = {
            "location": request.city,
            "checkIn": request.check_in,
            "checkOut": request.check_out,
            "adults": request.adults,
            "limit": request.limit * 2
        }
        
        hotels = await fetch_hotels(params)
        if not hotels:
            raise HTTPException(404, "–ü–æ –≤–∞—à–µ–º—É –∑–∞–ø—Ä–æ—Å—É –æ—Ç–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
        
        results = []
        for hotel in hotels:
            try:
                processed = process_hotel(hotel, nights)
                if not processed:
                    continue
                
                if request.stars and processed['stars'] not in request.stars:
                    continue
                if request.price_min and processed['price'] < request.price_min:
                    continue
                if request.price_max and processed['price'] > request.price_max:
                    continue
                
                results.append(processed)
                
                if len(results) >= request.limit:
                    break
                    
            except Exception as e:
                logger.warning(f"–ü—Ä–æ–ø—É—Å–∫–∞–µ–º –æ—Ç–µ–ª—å –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏: {str(e)}")
                continue
        
        if not results:
            raise HTTPException(404, "–ù–µ—Ç –æ—Ç–µ–ª–µ–π, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö –≤–∞—à–∏–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º")
        
        return results
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}", exc_info=True)
        raise HTTPException(500, "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞")
